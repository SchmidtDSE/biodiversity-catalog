{
  "hash": "7ad073bfe5013dc86ef81c288505a989",
  "result": {
    "markdown": "---\ntitle: Stac Tiling\n---\n\n\n# R\n\nHere we compute NDVI from sentinel2 over arbitrary data cube:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rstac)\nlibrary(gdalcubes)\nlibrary(stars)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: abind\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: sf\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLinking to GEOS 3.11.2, GDAL 3.6.4, PROJ 9.2.0; sf_use_s2() is TRUE\n```\n:::\n\n```{.r .cell-code}\nlibrary(tmap)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nThe legacy packages maptools, rgdal, and rgeos, underpinning this package\nwill retire shortly. Please refer to R-spatial evolution reports on\nhttps://r-spatial.org/r/2023/05/15/evolution4.html for details.\nThis package is now running under evolution status 0 \n```\n:::\n:::\n\n\nWe will search the STAC catalog for all satellite images in our desired space & time cube:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## STAC Search over 400 million assets.\nbox <- c(xmin=-122.51006, ymin=37.70801, xmax=-122.36268, ymax=37.80668) \nstart_date <- \"2022-06-01\"\nend_date <- \"2022-08-01\"\n\nitems <- \n  stac(\"https://earth-search.aws.element84.com/v0/\") |>\n  stac_search(collections = \"sentinel-s2-l2a-cogs\",\n              bbox = box,\n              datetime = paste(start_date, end_date, sep=\"/\"),\n              limit = 100) |>\n  post_request() \n```\n:::\n\n\nWe create an image collection of those features that have our desired bands, including the cloud image mask, and filtering out images with over 20% cloud covered (as denoted in their stac metadata)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol <-\n  stac_image_collection(items$features,\n                        asset_names = c(\"B04\",\"B08\", \"SCL\"),\n                        property_filter = \\(x) {x[[\"eo:cloud_cover\"]] < 20})\n```\n:::\n\n\nWe can now define our cube of interest.  Note that this specification is completely independent of the actual data assets -- the actual spatial and temporal resolution of the data could be finer or coarser than we request! A given x,y,t pixel in this abstract cube may be covered by multiple images (e.g. overlapping images, or multiple satellite fly-bys in the same week) -- and the code will aggregate them by the desired `aggregation` method (median).  Other such x,y,t pixels in the cube may have no data coverage at all -- perhaps the only images covering those pixels were removed by the cloud mask.  In this case, the pixels could be filled in by the `resampling` method (such as a spline, nearest-neighbor, or in this case, average of nearby pixels, See [gdalwarp](https://gdal.org/programs/gdalwarp.html).  Note that this approach means we can define both the projection and the spatio-temporal resolution of the output completely independently from the input.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncube <- cube_view(srs = \"EPSG:4326\",  \n                  extent = list(t0 = start_date, t1 = end_date,\n                                left = box[1], right = box[3],\n                                top = box[4], bottom = box[2]),\n                  nx = 2400, ny = 2400, dt = \"P1D\",\n                  aggregation = \"median\", resampling = \"average\")\n\nS2.mask <- image_mask(\"SCL\", values=c(3,8,9)) # mask clouds and cloud shadows\n\nvirtual_cube <- raster_cube(col, cube, mask = S2.mask)\n```\n:::\n\n\nObserve that this evaluation is \"lazy\", we haven't yet downloaded a single pixel of satellite imagery.  Using our virtual cube, we can reference just the bands of interest and perform arbitrary operations on the those pixels, e.g. to calculate NDVI.  This entire calculation happens over network interface range requests, first computing the aggregation and resampling warps.  See the [gdalcubes paper](https://doi.org/10.3390/data4030092) for details.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nndvi <- virtual_cube |>\n  select_bands(c(\"B04\", \"B08\")) |>\n  apply_pixel(\"(B08-B04)/(B08+B04)\", \"NDVI\") |>\n  reduce_time(c(\"mean(NDVI)\")) |>\n  st_as_stars()\n\ntm_shape(ndvi) + tm_raster(palette = viridisLite::mako(20), n=20)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nstars object downsampled to 1000 by 1000 cells. See tm_shape manual (argument raster.downsample)\n```\n:::\n\n::: {.cell-output-display}\n![](stac_tiling_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n# Python\n\n`pystac` + `stackstac` provides a comparable approach to `rstac` + `gdalcubes` approach.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pystac\nimport stackstac\n```\n:::\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "stac_tiling_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}